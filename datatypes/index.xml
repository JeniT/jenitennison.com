<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../resources/style/page.xsl"?>
<my:doc xmlns:xsi="http://www.w3.org/2000/10/XMLSchema-instance"
        xsi:schemaLocation="http://www.jenitennison.com/  
                            ../resources/schemas/doc.xsd"
        xmlns:my="http://www.jenitennison.com/"               
        xmlns="http://www.w3.org/1999/xhtml">
  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
    <rdf:Description xmlns:dc="http://purl.org/dc/elements/1.1/"
                     xmlns:dcq="http://purl.org/dc/qualifiers/1.0/"
                     about="/datatypes/index.xml">
      <dc:title>Datatype Library Language</dc:title>
      <dc:date xmlns:vcf="http://www.ietf.org/internet-drafts/draft-dawson-vcard-xml-dtd-03.txt">
        <rdf:Description dcq:dateType="created" dcq:dateScheme="W3C-DTF" rdf:value="2003-07-16"/>
      </dc:date>
      <dc:date xmlns:vcf="http://www.ietf.org/internet-drafts/draft-dawson-vcard-xml-dtd-03.txt">
        <rdf:Description dcq:dateType="modified" dcq:dateScheme="W3C-DTF" rdf:value="2003-07-16"/>
      </dc:date>
      <dc:creator rdf:resource="jeni@jenitennison.com"/>
      <link rel="stylesheet" href="../resources/style/base.css"/>
    </rdf:Description>
  </rdf:RDF>
  <h1>Datatype Library Language</h1>
  <p>
    This page describes some experiments that I've been doing with creating a
    declarative language that can describe datatype libraries for use in
    <my:link href="www.relaxng.org">RELAX NG</my:link> and
    <my:link href="www.w3.org/TR/xpath20">XPath 2.0</my:link>. It also might be
    interesting in terms of Part 5 (Datatypes) of <my:link href="www.dsdl.org">DSDL</my:link>.
  </p>
  <p>
    This page contains the following topics:
  </p>
  <ul>
    <li><my:link href="#motivation">Motivation</my:link> - why a datatype library language is useful</li>
    <li><my:link href="#language">Language Design</my:link> - how this language is designed and why</li>
    <li><my:link href="#implementation">Implementation</my:link> - some information about a proof-of-concept implementation</li>
    <li><my:link href="#todo">To Do List</my:link> - a list of issues and things left to do</li>
  </ul>
  <h2 id="motivation">Motivation</h2>
  <p>
    Unlike <my:link href="www.w3.org/TR/xmlschema-2">XML Schema</my:link>,
    RELAX NG doesn't provide a mechanism for users to define their own types.
    If they're not satisfied with the two built-in types of
    <code>string</code> and <code>token</code>, RELAX NG users have to create a
    <em>datatype library</em>, which they then refer to from the schema.
  </p>
  <p>
    Most RELAX NG validators provide built-in support for the XML Schema
    datatype library. Many also support an interface that allows you to plug in
    datatype modules, written in the programming language of your choice, to
    define extra datatypes. But the fact that these datatype libraries have to
    be programmed means that ordinary users find them hard to construct.
  </p>
  <p>
    One option would be for RELAX NG validators to support datatype definition
    via XML Schema - using <my:node>xs:simpleType</my:node> elements to create
    new atomic types. However, there are several problems with this:
  </p>
  <ul>
    <li>
      It wouldn't be particularly easy for implementations to support the
      <my:node>xs:simpleType</my:node> elements in isolation, but RELAX NG
      validators don't want to have to be able to understand XML Schema schemas.
    </li>
    <li>
      It wouldn't be particularly easy for RELAX NG users to switch to using the
      very different style employed by XML Schema, and again RELAX NG users
      don't want to have to be able to write XML Schema schemas.
    </li>
    <li>
      Creating user-defined datatypes based on the XML Schema datatypes means
      incorporating all the built-in types, including types that are unlikely be
      required for a particular schema.
    </li>
    <li>
      In general, the XML Schema type system goes against RELAX NG's open
      philosophy, for example by dictating the required format for numbers and
      dates when different markup languages might reasonably use different
      formats (for internationalisation reasons, for example).
    </li>
  </ul>
  <p>
    So the first motivation for putting together a language for datatype
    libraries is to enable RELAX NG users to construct their own datatypes
    without having to resort to a procedural programming language or having to
    learn how to use XML Schema, which might not be suited for their needs.
  </p>
  <p class="note">
    RELAX NG already supports the equivalent of union types and list types, plus
    the enumeration facet, so the only datatypes that we're concerned with here
    are atomic datatypes (in XML Schema-speak).
  </p>
  <p>
    The second motivation is to provide a mechanism for defining the datatypes
    that can be used in XPath 2.0, again without recourse to XML Schema. The
    noteworthy point here is that, as a processing language rather than a
    validation language, XPath 2.0 has slightly different requirements from a
    datatype library language than RELAX NG validators.
  </p>
  <h2 id="language">Language Design</h2>
  <p>
    This is what I've put together. I've tried to explain the choices that I've
    made, because they certainly weren't the only possible choices and I'm not
    sure that they were necessarily the right ones. A
    <my:link href="datatypes.rnc">RELAX NG Compact</my:link> schema is available,
    as are <my:link href="datatypes.rng">RELAX NG</my:link> and
    <my:link href="datatypes.xsd">XML Schema</my:link> versions courtesy of
    <my:link href="http://www.thaiopensource.com/relaxng/trang.html">Trang</my:link>.
  </p>
  <p>
    This section describes how to use the datatype library language, as follows:
  </p>
  <ul>
    <li><my:link href="#naming">Naming</my:link> - how to specify the name of a datatype</li>
    <li><my:link href="#parsing">Parsing</my:link> - how to specify how strings are parsed into values of a particular type</li>
    <li><my:link href="#validating">Validating</my:link> - how to specify how values are further checked to ensure they're validated</li>
    <li><my:link href="#validating">XPath and XSLT</my:link> - how and why XPath and XSLT are used within the language</li>
    <li><my:link href="#normalizing">Normalizing</my:link> - how to specify how values are normalized</li>
    <li><my:link href="#comparing">Comparing</my:link> - how to specify how values are compared</li>
    <li><my:link href="#hierarchies">Datatype Hierarchies</my:link> - how to build datatype hierarchies</li>
    <li><my:link href="#parameters">Parameters</my:link> - how to specify parameters that can be set for subtypes</li>
    <li><my:link href="#casting">Casting</my:link> - how to specify how values are cast between types</li>
    <li><my:link href="#sharing">Datatype Sharing</my:link> - how to share definitions of va                        DEB(
			if (debugging && STps->eof != ST_NOEOF)
				printk(ST_DEB_MSG
                                       "st%d: EOF up (%d). Left %d, needed %d.\n", dev,
				       STps->eof, (STp->buffer)->buffer_bytes,
                                       count - total);
                        ) /* end DEB */
			transfer = (STp->buffer)->buffer_bytes < count - total ?
			    (STp->buffer)->buffer_bytes : count - total;
			i = from_buffer(STp->buffer, buf, transfer);
			if (i) {
				retval = i;
				goto out;
			}
			pos += transfer;
			buf += transfer;
			total += transfer;
		}

		if (STp->block_size == 0)
			break;	/* Read only one variable length block */

	}			/* for (total = 0, special = 0;
                                   total < count && !special; ) */

	/* Change the eof state if no data from tape or buffer */
	if (total == 0) {
		if (STps->eof == ST_FM_HIT) {
			STps->eof = ST_FM;
			STps->drv_block = 0;
			if (STps->drv_file >= 0)
				STps->drv_file++;
		} else if (STps->eof == ST_Er:</p>
  <my:example><![CDATA[
<datatypes xmlns="http://www.jenitennison.com/datatypes"
           ns="http://www.example.com/datatypes">
  <datatype name="date">
    ...
  </datatype>
</datatypes>
  ]]></my:example>
  <p>
    The <my:node type="attribute">ns</my:node> attribute is also used to provide a
    default namespace whenever another datatype gets referenced. This makes it
    easy to write a self-contained datatype library without ever using colonised
    names.
  </p>
  <h3>Parsing</h3>
  <p>
    The main thing that's required for a validator to check whether an element
    or attribute value is of a particular datatype is the ability to parse that
    value. This is also needed when constructing values from strings within a
    language like XPath. The way that a string is parsed is determined by the
    content of the <my:node>parse</my:node> element.
  </p>
  <p>
    The first step of the parsing is whitespace processing. This is controlled
    using the <my:node type="attribute">whitespace</my:node> attribute on the
    <my:node>parse</my:node> element, which can have the values
    <my:value type="string">preserve</my:value>, which keeps whitespace as it
    is; <my:value type="string">replace</my:value>, which replaces all
    whitespace characters with space characters; and
    <my:value type="string">collapse</my:value>, which normalizes the string
    by stripping leading and trailing whitespace and replacing any sequences of
    whitespace characters with a single space. The default value is
    <my:value type="string">collapse</my:value>, such that leading and trailing
    whitespace isn't significant within a value.
  </p>
  <p class="note">
    This is equivalent to the whitespace processing offered by XML Schema. I'm
    not sure that the <my:value type="string">replace</my:value> value is really
    necessary, but one goal is that this language should be able to be used to
    define the XML Schema datatypes, and it is necessary for that.
  </p>
  <p>
    At a basic level, this is done using a XML version of the regular
    expression language used by XML Schema. The main elements that are used and
    the corresponding regular expression syntax is shown in the following table.
  </p>
  <table>
    <thead>
      <tr><th>Element</th><th>Regex</th><th>Notes</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><code><![CDATA[<choice>...</choice>]]></code></td>
        <td><code>(...|...)</code></td>
        <td>Each separate element within the <my:node>choice</my:node> becomes a separate choice</td>
      </tr>
      <tr>
        <td><code><![CDATA[<group>...</group>]]></code></td>
        <td><code>(...)</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<optional>...</optional>]]></code></td>
        <td><code>(...)?</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<zeroOrMore>...</zeroOrMore>]]></code></td>
        <td><code>(...)*</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<oneOrMore>...</oneOrMore>]]></code></td>
        <td><code>(...)+</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<repeat exactly="n">...</repeat>]]></code></td>
        <td><code>(...){n}</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<repeat min="n">...</repeat>]]></code></td>
        <td><code>(...){n,}</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<repeat max="m">...</repeat>]]></code></td>
        <td><code>(...){0,m}</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<repeat min="n" max="m">...</repeat>]]></code></td>
        <td><code>(...){n,m}</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<string>...</string>]]></code></td>
        <td><code>...</code></td>
        <td>The characters within the <my:node>string</my:node> element that are significant for regex processing are escaped</td>
      </tr>
      <tr>
        <td><code><![CDATA[<charGroup>...</charGroup>]]></code></td>
        <td><code>[...]</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<notCharGroup>...</notCharGroup>]]></code></td>
        <td><code>[^...]</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<range from="c" to="d" />]]></code></td>
        <td><code>c-d</code></td>
        <td>This is used within a <my:node>charGroup</my:node> or <my:node>notCharGroup</my:node> element</td>
      </tr>
      <tr>
        <td><code><![CDATA[<range>...</range>]]></code></td>
        <td><code>...-...</code></td>
        <td>In this form, the <my:node>range</my:node> element can only have two children</td>
      </tr>
      <tr>
        <td><code><![CDATA[<except>...</except>]]></code></td>
        <td><code>-[...]</code></td>
        <td>This is used within a <my:node>charGroup</my:node> or <my:node>notCharGroup</my:node> element</td>
      </tr>
      <tr>
        <td><code><![CDATA[<chars>...</chars>]]></code></td>
        <td><code>...</code></td>
        <td>The characters that would be significant within a character group (i.e. <code>\</code>, <code>[</code> and <code>]</code>) are escaped</td>
      </tr>
      <tr>
        <td><code><![CDATA[<anyChar />]]></code></td>
        <td><code>.</code></td>
        <td>Unlike in the XML Schema regular expression syntax, this should match any character, including newlines</td>
      </tr>
      <tr>
        <td><code><![CDATA[<newline />]]></code></td>
        <td><code>\n</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<return />]]></code></td>
        <td><code>\r</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<tab />]]></code></td>
        <td><code>\t</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<whitespace />]]></code></td>
        <td><code>\s</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<notWhitespace />]]></code></td>
        <td><code>\S</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<initialNameChar />]]></code></td>
        <td><code>\i</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<notInitialNameChar />]]></code></td>
        <td><code>\I</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<nameChar />]]></code></td>
        <td><code>\c</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<notNameChar />]]></code></td>
        <td><code>\C</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<digit />]]></code></td>
        <td><code>\d</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<notDigit />]]></code></td>
        <td><code>\D</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<wordChar />]]></code></td>
        <td><code>\w</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<notWordChar />]]></code></td>
        <td><code>\W</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<category>C</category>]]></code></td>
        <td><code>\p{C}</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<notCategory>C</notCategory>]]></code></td>
        <td><code>\P{C}</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<block>B</block>]]></code></td>
        <td><code>\p{IsB}</code></td>
        <td></td>
      </tr>
      <tr>
        <td><code><![CDATA[<notBlock>B</notBlock>]]></code></td>
        <td><code>\P{IsB}</code></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <p>
    Basically, as long as these are arranged in such a way that you get a
    legal regular expression, it's OK. As an example, here's what the parsing
    for a <code>decimal</code> datatype looks like:
  </p>
  <my:example><![CDATA[
<datatype name="decimal">
  <parse>
    <optional>
      <choice>
        <string>+</string>
        <string>-</string>
      </choice>
    </optional>
    <oneOrMore>
      <charGroup>
        <range from="0" to="9" />
      </charGroup>
    </oneOrMore>
    <optional>
      <string>.</string>
      <oneOrMore>
        <charGroup>
          <range from="0" to="9" />
        </charGroup>
      </oneOrMore>
    </optional>
  </parse>
</datatype>
  ]]></my:example>
  <p>The corresponding regular expression is:</p>
  <my:example>(+|-)?[0-9]+(.[0-9]+)?</my:example>
  <p class="note">
    A strict translation would have more brackets in it; I removed them for
    clarity.
  </p>
  <p>
    If you don't specify a <my:node>parse</my:node> element, then the default
    regular expression that's used is simply <code>.*</code>, and there's
    no whitespace normalization prior to parsing, so all whitespace gets
    preserved.
  </p>
  
  <h4>Named Patterns</h4>
  <p>
    To make life easier, as in RELAX NG you can name patterns that you want to
    use over and over again using <my:node>define</my:node> elements at the top
    level of the library. You can then refer to them with <my:node>ref</my:node>
    elements within a pattern, like so:
  </p>
  <my:example><![CDATA[
<define name="Digit">
  <charGroup>
    <range from="0" to="9" />
  </charGroup>
</define>

<define name="Digits">
  <oneOrMore>
    <ref name="Digit" />
  </oneOrMore>
</define>

<datatype name="decimal">
  <parse>
    <optional>
      <choice>
        <string>+</string>
        <string>-</string>
      </choice>
    </optional>
    <ref name="Digit" />
    <optional>
      <string>.</string>
      <ref name="Digit" />
    </optional>
  </parse>
</datatype>
  ]]></my:example>
  <p>
    As in RELAX NG, named patterns can't be circular: within a pattern, you
    can't refer to another pattern that (eventually) refers to that same
    pattern. This ensures that the patterns can be used to create a regular
    expression, but it does mean that certain datatypes (for example XPaths)
    can't be defined. I'm not sure whether this rule should be relaxed, but I
    think it would greatly complicate things if it were.
  </p>
  
  <h4>Parsing Result</h4>
  <p>
    Taking inspiration from Simon St. Laurent's
    <my:link href="http://www.simonstl.com/projects/fragment/">Regular Fragmentations</my:link>,
    the result of parsing the string is, at least at a conceptual level, an XML
    fragment (in XPath 2.0 terms, a document whose root node is an element node).
    <my:aside>I don't think that it has to be represented this way internally by
    an implementation, but XML is a familiar kind of structure for users, and we
    have lots of tools for manipulating it...</my:aside>
  </p>
  <p>
    The root element is named after the data type and its string value
    should give a legal lexical representation for the value. The default parse
    generates an element with a single text node as its child.
  </p>
  <p>
    Parsing can generate an internal structure for the value in two ways. First,
    it's possible to name groups within the parse pattern; these groups become
    elements within the result of parsing the string. For example, if you do:
  </p>
  <my:example><![CDATA[
<datatype name="decimal">
  <parse>
    <group name="sign">
      <optional>
        <choice>
          <string>+</string>
          <string>-</string>
        </choice>
      </optional>
    </group>
    <group name="whole-part">
      <ref name="Digit" />
    </group>
    <optional>
      <string>.</string>
      <group name="fraction-part">
        <ref name="Digit" />
      </group>
    </optional>
  </parse>
</datatype>
  ]]></my:example>
  <p>
    and then parse the value <my:value type="string">12.50</my:value> then the
    result is:
  </p>
  <my:example><![CDATA[
<my:decimal xmlns:my="http://www.example.com/datatypes">
  <my:whole-part>12</my:whole-part>.<my:fraction-part>50</my:fraction-part>
</my:decimal>
  ]]></my:example>
  <p class="note">
    Note that components that don't have any string value aren't included in
    the parsed value.
  </p>
  <p>
    More generally, you can refer to another datatype in order to create a
    particular component, using a <my:node>data</my:node> element whose
    <my:node type="attribute">type</my:node> attribute points to another
    datatype. For example, if I defined the type <code>sign</code> as:
  </p>
  <my:example><![CDATA[
<datatype name="sign">
  <parse>
    <optional>
      <choice>
        <string>+</string>
        <string>-</string>
      </choice>
    </optional>
  </parse>
</datatype>
  ]]></my:example>
  <p>
    then I can refer to that datatype from the <code>decimal</code> datatype as
    follows:
  </p>
  <my:example><![CDATA[
<datatype name="decimal">
  <parse>
    <data type="sign" />
    <group name="whole-part">
      <ref name="Digit" />
    </group>
    <optional>
      <string>.</string>
      <group name="fraction-part">
        <ref name="Digit" />
      </group>
    </optional>
  </parse>
</datatype>
  ]]></my:example>
  <p>
    Using this definition, if you parse the value
    <my:value type="string">-1000</my:value> then the result is:
  </p>
  <my:example><![CDATA[
<my:decimal xmlns:my="http://www.example.com/datatypes">
  <my:sign>-</my:sign><my:whole-part>1000</my:whole-part>
</my:decimal>
  ]]></my:example>
  <p>
    As well as being parsed according to the <code>sign</code> datatype,
    whatever part of the string matches that datatype is treated as that
    datatype when it comes to validating, as we'll see later.
  </p>
  <p class="note">
    You can think of using a named group as equivalent to defining a local,
    anonymous datatype with no extra validation checks.
  </p>
  <p>
    An extra twist on the parsing front is that you can label any pattern as
    ignorable using an <my:node type="attribute">ignore</my:node> attribute
    with the value <my:value type="string">yes</my:value>. The string matching
    the pattern isn't included in the result of the parse. This is useful when
    the presence of the pattern shouldn't make any difference to how the value
    is interpreted, for example the <code>+</code> sign:
  </p>
  <my:example><![CDATA[
<datatype name="sign">
  <parse>
    <optional>
      <choice>
        <string ignore="yes">+</string>
        <string>-</string>
      </choice>
    </optional>
  </parse>
</datatype>
  ]]></my:example>
  <p>
    The result here would be that parsing the string
    <my:value type="string">+12.50</my:value> would give exactly the same result
    as parsing the string <my:value type="string">12.50</my:value>. You can use
    this to ignore leading and trailing zeros, for example.
  </p>
  <p class="note">
    I'm not certain about this feature: it offers a basic form of normalisation
    during parsing, but I'm not convinced there are enough use cases to make it
    really worthwhile.
  </p>

  <h3>Validating</h3>
  <p>
    Being able to specify the regular expression that a value must conform to is
    often enough, but sometimes there are extra properties of a datatype that
    need to be validated or that are really tedious to write regular expressions
    for. An example is dates: although you can write a regular expression for a
    date, it's a lot easier to express the constraints between years, months and
    days as tests on those components.
  </p>
  <p>
    Validation is specified through a <my:node>validate</my:node> element whose
    content closely resembles that of a <my:node>rule</my:node> element in
    <my:link href="http://www.ascc.net/xml/schematron/">Schematron</my:link>.
    It can have <my:node>report</my:node> and <my:node>assert</my:node> elements,
    each of which have <my:node type="attribute">test</my:node> attributes and
    content that provides a message.
  </p>
  <p>
    The <my:node type="attribute">test</my:node> attributes contain XPath 2.0
    expressions, which are evaluated with the root element of the parsed value
    as the context item. To make life easier for the user, the default element
    namespace (used for resolving element names without prefixes) is set to the
    same namespace as the datatype, so that its components can be referred to
    without using prefixes.
  </p>
  <p>
    If the <my:node type="attribute">test</my:node> attribute of a
    <my:node>report</my:node> element evaluates as <my:value type="boolean">true</my:value>
    then the content it holds is reported as an error message. Similarly, if the
    <my:node type="attribute">test</my:node> attribute of an
    <my:node>assert</my:node> element evaluates as <my:value type="boolean">false</my:value>
    then you get an error message.
  </p>
  <p>
    In the current design, the error message can contain XSLT instructions, just
    as it can in Schematron.
  </p>
  <p>
    For example, assuming that the datatypes <code>year</code>, <code>month</code>
    and <code>day</code> were defined appropriately, a date might look like:
  </p>
  <my:example><![CDATA[
<datatype name="date">
  <parse>
    <data type="year" />
    <string>-</string>
    <data type="month" />
    <string>-</string>
    <data type="day" />
  </parse>
  <validate>
    <report test="day > 30 and month = (4, 6, 9, 11)">
      Month <value-of select="month" /> only has 30 days.
    </report>
    <report test="month = 2 and day > 29">
      February never has more than 29 days.
    </report>
    <report test="month = 2 and day = 29 and
                  (year mod 4 or (not(year mod 100) and year mod 400))">
      In <value-of select="year" />, February had 28 days.
    </report>
  </validate>
</datatype>
  ]]></my:example>
  <p>
    If you refer to other datatypes to created components for a datatype, then
    the values of those components get validated according to that datatype.
    For example, the <code>year</code>, <code>month</code> and <code>day</code>
    components could have their own validation rules:
  </p>
  <my:example><![CDATA[
<datatype name="year">
  <parse>
    <repeat min="4"><ref name="Digit" /></repeat>
  </parse>
  <validate>
    <report test=". = 0">There is no year 0.</report>
  </validate>
</datatype>

<datatype name="month">
  <parse>
    <repeat exactly="2"><ref name="Digit" /></repeat>
  </parse>
  <validate>
    <assert test=". > 0 and . &lt;= 12">There are only 12 months, and the first is month 1</report>
  </validate>
</datatype>

<datatype name="day">
  <parse>
    <repeat exactly="2"><ref name="Digit" /></repeat>
  </parse>
  <validate>
    <assert test=". > 0 and . &lt;= 31">The maximum days in a month is 31.</report>
  </validate>
</datatype>
  ]]></my:example>
  <p>
    These rules would be applied to the <code>year</code>, <code>month</code>,
    and <code>day</code> components of the <code>date</code> type.
  </p>
  <p>
    If you don't specify a <my:node>validate</my:node> element within a datatype
    definition then no extra validation gets done (aside from that done on the
    individual components).
  </p>
  
  <h3>XPath and XSLT</h3>
  <p>
    Since this is the first introduction of the idea of using XPath and XSLT
    within the datatype definitions, I'll just take some time to justify it.
  </p>
  <p>
    First, I don't think that using XPath needs any justification. There are
    enough XPath libraries around that I think that any implementation should
    be able to cobble together support for it. Using XPath 2.0 is more
    controversial: my justification is that the ability to use unprefixed names
    in the XPaths makes the datatype library language hang together much more
    easily. Plus XPath 2.0 is that much more powerful. As a "host language",
    the datatype library language could restrict the features of XPath 2.0 that
    get used; for example, I don't think that using XPath 2.0 here should
    require support for all the XML Schema datatypes (the XPath 1.0 datatypes
    are enough for what we need to do).
  </p>
  <p>
    XSLT is more contentious, I imagine. I used it because I'm an XSLT weenie,
    and because I wanted to get an implementation of this off the ground
    quickly as a proof of concept. The XSLT use in the datatype library language
    is pretty restricted - there's no need for templates, for example - so that
    should make implementation, either through interpretation or compilation, a
    lot simpler. Plus, again there are lots of open-source implementations
    (at least of XSLT 1.0) that could be used. The other big advantages are that
    it's declarative, is designed around constructing XML content and that it
    has a syntax that's easily embedded in XML documents.
  </p>
  <p>
    Having said that, XQuery would also (probably) meet these criteria, so
    perhaps the places where code can be used should accept either XSLT or
    XQuery (or allow users to supply both). Or perhaps the datatype library
    language should go the other way and create its own set of instructions
    to do the tasks that need to be done with code. I'm not sure.
  </p>

  <h3>Normalizing</h3>
  <p>
    The datatype definition language borrows from XML Schema the notion of the
    "value space" and the "lexical space", with one-to-many relationships
    between values and lexical representations. In other words, a value has many
    possible lexical representations.
  </p>
  <p>
    In XML Schema, one of the possible lexical representations of a value is
    known as the canonical lexical representation. Canonical lexical
    representations are useful because they enable applications to store the
    values directly, and reconstruct a lexical representation for the value.
    They can also be useful when comparing two values since two values are only
    equal if their canonical lexical representations are equal.
  </p>
  <p>
    The datatype library language allows you to specify how a value gets
    normalized with the <my:node>normalize</my:node> element. The content is
    XSLT code that generates the content of the normalized value with the
    original value as the context node. An example might be to normalize a
    <code>time</code> based on its <code>timezone</code> component, which
    might look something like:
  </p>
  <my:example><![CDATA[
<datatype name="time">
  ...
  <normalize>
    <choose>
      <when test="timezone != 'Z'">
        <variable name="minute"
          select="minute + (if (timezone/hours >= 0) then timezone/minutes else - timezone/minutes)" />
        <variable name="add-hour"
          select="if ($minute >= 60) then 1
                  else if ($minute &lt; 0) then -1
                  else 0" />
        <variable name="minute" select="$minute - $add-hour * 60" />
        <variable name="hour" select="hour - timezone/hours + $add-hour" />
        <variable name="add-day"
          select="if ($hour >= 24) then 1
                  else if ($hour &lt; 0) then -1
                  else 0" />
        <variable name="hour" select="$hour - $add-day * 24" />
        <my:hour><value-of select="format-number($hour, '00')" /></my:hour>
        <text>:</text>
        <my:minute><value-of select="format-number($minute, '00')" /></my:minute>
        <text>:</text>
        <my:second><value-of select="second" /></my:second>
        <my:timezone>Z</my:timezone>
      </when>
      <otherwise>
        <copy-of select="node()" />
      </otherwise>
    </choose>
  </normalize>
</datatype>
]]></my:example>
  <p>
    If you don't specify a <my:node>normalize</my:node> element within a datatype,
    nothing happens during normalization - you get the same value out as you
    put in.
  </p>
  <p>
    The normalized value is also used to create a string from a value: just
    take the string value of the root element of the normalized value.
  </p>

  <h3>Comparing</h3>
  <p>
    The principal reason for normalizing values is so that you can compare them
    more easily. Comparisons are defined through the <my:node>compare</my:node>
    element. I wanted to avoid using XSLT as much as possible, so comparing
    values is done through a mechanism that's similar to the sorting mechanism
    in XSLT.
  </p>
  <p>
    The <my:node>compare</my:node> element has within it various other
    <my:node>compare</my:node> elements, each of which has a
    <my:node type="attribute">path</my:node> attribute that points to a
    component of the datatype. For example, the comparison of two times with
    optional timezones, and with the normalization described above, might be
    done with:
  </p>
  <my:example><![CDATA[
<datatype name="time">
  ...
  <compare>
    <compare path="timezone" />
    <compare path="hour" />
    <compare path="minute" />
    <compare path="second" />
  </compare>
</datatype>
]]></my:example>
  <p>
    When comparing two values, the components specified by the
    <my:node>compare</my:node> elements are compared in turn. If a component is
    present on one value but absent on another, then it's an error, so the
    definition above means that you can't compare two times if one has a timezone
    and the other doesn't, for example. Otherwise, if the component has the
    same value on both values being compared, then you move on to the next
    component. If they all end up equal then the values are judged to be equal.
  </p>
  <p>
    You can specify an <my:node type="attribute">as</my:node> attribute on the
    <my:node>compare</my:node> elements to describe how the components themselves
    should be compared. Currently, only alphabetical (<code>string</code>) and
    numeric (<code>number</code>) comparisons are used, but probably you should
    be able to compare values using any of the datatypes available to the
    library as well. I also thought that being able to specify a particular
    collation (through a URL) might be useful here, to make it easy to define
    datatypes that should be compared in a particular way.
  </p>
  <p>
    If you don't specify a <my:node>compare</my:node> element for a datatype,
    then by default they're compared as strings.
  </p>

  <h3>Datatype Hierarchies</h3>
  <p>
    It's really helpful for datatypes to be arranged in hierarchies - to allow
    inheritance - because datatype definitions are easier to read and write this
    way. This is done through an optional <my:node>supertype</my:node> element,
    whose <my:node type="attribute">name</my:node> attribute points to the
    relevant datatype definition. For example, to say that the type
    <my:value>price</my:value> is derived from the type <my:value>decimal</my:value>,
    I can use:
  </p>
  <my:example><![CDATA[
<datatype name="price">
  <supertype name="decimal" />
</datatype>
]]></my:example>
  <p class="note">
    The current language doesn't support multiple inheritance, but it would be
    easy to say that you could have multiple <my:node>supertype</my:node>
    elements within a datatype, if we could work out the semantics of doing so.
  </p>
  <p>
    Inheriting from a supertype means that whenever something isn't specified
    on the given type, you use the supertype's definition to do it instead (or
    that type's supertype and so on). For example, if you don't specify the
    <my:node>compare</my:node> element then values of the subtype will be
    compared in the same way as values of its supertype.
  </p>
  <p>
    To ensure that a value of a particular subtype is also a legal value of
    the subtype's supertype, when parsing a string as a subtype, not only must
    the string match the regular expression specified for the subtype, but it
    must also match the regular expression specified for the supertype.
    Similarly, when validating a value of a subtype, it must also validate
    against the supertype's constraints.
  </p>
  <p class="note">
    You can think of this as meaning that the patterns in the <my:node>parse</my:node>
    elements are combined using a <em>concur</em> pattern (as in RELAX NG),
    and that the tests in the <my:node>validate</my:node> element are simply
    concatenated, such that they all apply.
  </p>
  
  <h3>Parameters</h3>
  <p>
    As part of supporting inheritance, it's useful to write datatype definitions
    using facets (in XML Schema-speak) or parameters (in RELAX NG-speak) (which
    RELAX NG also allows to be used within the schema itself). A datatype
    definition can define any legal parameters and how they can be tested;
    subtypes of that datatype can then define values for those parameters within.
  </p>
  <p>
    Parameters are defined in a type using a <my:node>params</my:node> element,
    which contains a number of <my:node>param</my:node> elements. Each
    <my:node>param</my:node> element has a <my:node type="attribute">name</my:node>
    attribute which supplies a name for the parameter.
  </p>
  <p>
    <my:node>param</my:node> elements must have a <my:node type="attribute">test</my:node>
    attribute, a <my:node type="attribute">select</my:node> attribute, or both.
    The <my:node type="attribute">select</my:node> attribute specifies what
    should be tested, using an XPath, and the <my:node type="attribute">test</my:node>
    attribute specifies the kind of comparison that should be used. If the
    <my:node type="attribute">select</my:node> attribute is missing, then the
    string value of the value as a whole is tested; if the <my:node type="attribute">test</my:node>
    attribute is missing then the <my:node type="attribute">select</my:node>
    attribute is treated as a boolean test. An <my:node type="attribute">as</my:node>
    attribute can indicate whether numeric or alphabetic comparisons should
    be carried out.
  </p>
  <p>
    For example, here's what the parameters on a <code>decimal</code> type
    might look like:
  </p>
  <my:example><![CDATA[
<datatype name="decimal">
  <params>
    <param name="signed" select="sign" />
    <param name="minInclusive" test="ge" as="number" />
    <param name="maxInclusive" test="le" as="number" />
    <param name="decimalPlaces" test="eq" select="string-length(fraction-part)" as="number" />
  </params>
</datatype>
]]></my:example>
  <p>
    The <code>signed</code> parameter tests whether or not a sign is present,
    and can be set to <my:value type="boolean">true</my:value> (there must be
    a sign) or <my:value type="boolean">false</my:value> (there must not be a
    sign). The <code>minInclusive</code> and <code>maxInclusive</code> parameters
    test the value of the decimal; the value must be greater than or equal to
    the value of the <code>minInclusive</code> parameter and less than or
    equal to the value of the <code>maxInclusive</code> parameter. The
    <code>decimalPlaces</code> parameter indicates the length of the
    <code>fraction-part</code> component. Note that all these tests are done on
    the original, unnormalized, value.
  </p>
  <p>
    A subtype can specify values for any of the parameters defined by its
    supertype (or its supertype's supertype and so on). These parameters are
    specified within a <my:node>params</my:node> element within the <my:node>supertype</my:node>
    element, with the parameters being listed with <my:node>param</my:node>
    elements whose <my:node type="attribute">name</my:node> attribute specifies
    the name of the parameter and whose value specifies its value.
  </p>
  <p>
    For example, a <code>price</code> type might be defined with:
  </p>
  <my:example><![CDATA[
<datatype name="price">
  <supertype name="decimal">
    <params>
      <param name="signed">false</param>
      <param name="minInclusive">0.01</param>
      <param name="decimalPlaces">2</param>
    </params>
  </supertype>
</datatype>
]]></my:example>
  <p>
    This specifies that there must not be a <code>sign</code> component, that
    the value of the price must be more than 0.01 and that it must specify
    two decimal places. Of course the same effect could be achieved by giving
    a <my:node>parse</my:node> element that only allowed lexical representations
    that met these conditions, but using parameters is a lot cleaner and makes
    it easier for an implementation to check, statically, that all values of
    a subtype are going to be legal values for the supertype.
  </p>
  
  <h3>Casting</h3>
  <p>
    In general, the datatype library language assumes that you can cast between
    two types by formatting the value of the first type as a string (getting
    the string value of the normalized value) and then parsing it as if it were
    a value of the second type. However, this rule can be overridden by
    specifying particular casting rules.
  </p>
  <p>
    One set of casting rules comes when defining subtypes. Within a <my:node>supertype</my:node>
    element, you can have a <my:node>cast</my:node> element that holds code
    that converts a value of the supertype to a value of the subtype. If this
    code returns nothing, that means that casting of that particular value
    isn't possible. For example, the following specifies that you can cast
    a <code>decimal</code> to a <code>price</code> as long as it doesn't have
    a negative sign; the cast is done by formatting the <code>fraction-part</code>
    component so that it has two digits:
  </p>
  <my:example><![CDATA[
<datatype name="price">
  <supertype name="decimal">
    <cast>
      <if test="not(sign = '-')">
        <copy-of select="whole-part" />
        <text>.</text>
        <my:fraction-part>
          <value-of select="substring(concat(fraction-part, '00'), 1, 2)" />
        </my:fraction-part>
      </if>
    </cast>
  </supertype>
</datatype>
]]></my:example>
  <p class="note">
    Note that this code currently requires the new <code>fraction-part</code>
    component to be specified using an element in the
    <my:value type="string">http://www.example.com/datatypes</my:value> namespace.
    Namespaces are a bit of a mess here because the XSLT parts of the code are
    in the default, <my:value type="string">http://www.jenitennison.com/datatypes</my:value>
    namespace but really we want to be able to use the namespace specified by
    the nearest <code>ns</code> attribute for generating new component elements.
    Any ideas?
  </p>
  <p>
    Casting from supertype to subtype is transitive, so just specifying the
    casting rules from supertype to subtype gives you casting rules from
    supertype's supertype to subtype's subtype and so on. But you can also
    define casting rules between any two types using a <my:node>cast</my:node>
    element.
  </p>
  <p>
    The <my:node>cast</my:node> elements live at the top of the datatype library
    file and have <my:node type="attribute">from</my:node> and
    <my:node type="attribute">to</my:node> attributes that specify which
    datatypes can be cast to each other. The content is code that generates the
    content of the new datatype from the old. For example, the following defines
    two different date formats and how to cast between them:
  </p>
  <my:example><![CDATA[
<datatype name="ISODate">
  <parse>
    <data type="year" />
    <string>-</string>
    <data type="month" />
    <string>-</string>
    <data type="day" />
  </parse>
</datatype>

<datatype name="UKDate">
  <parse>
    <data type="day" />
    <string>/</string>
    <data type="month" />
    <string>/</string>
    <data type="year" />
  </parse>
</datatype>

<cast from="ISODate" to="UKDate">
  <copy-of select="day" />
  <text>/</text>
  <copy-of select="month" />
  <text>/</text>
  <copy-of select="year" />
</cast>

<cast from="UKDate" to="ISODate">
  <copy-of select="year" />
  <text>-</text>
  <copy-of select="month" />
  <text>-</text>
  <copy-of select="day" />
</cast>
]]></my:example>
  <p>
    When casting rules are established in this way, every subtype of the
    types that are involved can take advantage of them. For example, to cast
    from a subtype of the <code>ISODate</code> to a subtype of the <code>UKDate</code>,
    you would cast the value to a <code>UKDate</code> using the casting rule
    above, and then down to the subtype of the <code>UKDate</code> using the
    supertype-subtype casting rule.
  </p>

  <h3>Datatype Sharing</h3>
  <p>
    If you have casting rules set up, it's then an easy step to sharing the
    mechanisms for validating, normalizing and comparing values of different
    datatypes. This is done through <my:node type="attribute">as</my:node>
    attributes on the <my:node>validate</my:node>, <my:node>normalize</my:node>
    and <my:node>compare</my:node> elements, which gives the name of the
    datatype whose definitions should be reused.
  </p>
  <p>
    For example, say that the definition of <code>ISODate</code> contained a
    lot of code for validating, normalizing and comparing dates. <code>UKDate</code>
    values could be cast to <code>ISODate</code> values and then validated or
    compared. When it comes to normalization, the <code>UKDate</code> values
    could be cast to <code>ISODate</code> values, normalized, and then cast
    back to <code>UKDate</code> values. To set this up, the definition of
    <code>UKDate</code> needs to look like:
  </p>
  <my:example><![CDATA[
<datatype name="UKDate">
  <parse>
    <data type="day" />
    <string>/</string>
    <data type="month" />
    <string>/</string>
    <data type="year" />
  </parse>
  <validate as="ISODate" />
  <normalize as="ISODate" />
  <compare as="ISODate" />
</datatype>
]]></my:example>

  <h3>Context</h3>
  <p>
    Context is important when converting a lexical representation into a
    value, and when converting a value into a canonical lexical
    representation. What aspects of context are important depends on the
    datatype. Examples are:
  </p>
  <ul>
    <li>in-scope namespace declarations (for QNames)</li>
    <li>in-scope base URI (for URIs)</li>
  </ul>
  <p>
    Other items that might be useful from the context of a value include
    the current language (from xml:lang), the local language, the current
    date/time, the local timezone and so on.
  </p>
  <p class="note">
    I haven't incorporated context into the datatype library language yet; it's
    on the to-do list...
  </p>

  <h2 id="implementation">Implementation</h2>
  <p>
    I wanted to try this all out, of course, so I put together a proof-of-concept
    implementation. This is just an XSLT 2.0 stylesheet that generates another
    XSLT 2.0 stylesheet that contains a bunch of functions that enable you to
    manipulate the datatypes defined in a datatype library. These have been
    developed and (not particularly rigorously) tested using
    <my:link href="saxon.sourceforge.net">Saxon 7.6.5</my:link>.
  </p>
  <p>
    The XSLT 2.0 stylesheet that does the conversion is
    <my:link href="datatypes.xsl">datatypes.xsl</my:link>. It includes the
    XSLT 2.0 stylesheet module <my:link href="datatypes-expand.xsl">datatypes-expand.xsl</my:link>,
    so make sure you get that as well if you want to try it out.
  </p>
  <p>
    The result of transforming a datatype library document with datatypes.xsl is
    another XSLT 2.0 stylesheet. For each datatype called <code>ns:type</code>,
    this stylesheet contains the following functions:
  </p>
  <dl>
    <dt><code>ns:type($type as item()) returns element()</code></dt>
    <dd>
      This is the constructor for the datatype. The argument can be any kind of
      value, which is cast to the relevant type. The value is returned as an
      element with the specified name. An error is raised if the argument can't
      be cast to a legal value of the type.
    </dd>
    <dt><code>ns:format-type($type as element()) returns xs:string</code></dt>
    <dd>
      This returns the canonical lexical representation of a value, by
      normalizing it and giving the string value of the result.
    </dd>
    <dt><code>ns:normalize-type($type as element()) returns element()</code></dt>
    <dd>
      This normalizes the value passed as the argument and returns the result.
    </dd>
    <dt><code>ns:compare-types($type1 as element(), $type2 as element()) returns xs:integer</code></dt>
    <dd>
      This compares the first argument with the second, and returns
      <my:value type="number">0</my:value> if they are equal,
      <my:value type="number">-1</my:value> if the first argument is less than
      the second, and <my:value type="number">1</my:value> if the first argument
      is more than the second. Of course what "less than" and "more than" mean
      depends on the datatype definition.
    </dd>
    <dt><code>ns:parse-type($string as xs:string) returns element()?</code></dt>
    <dd>
      This parses a string based on the parsing rules for the datatype. If the
      string is a legal lexical representation based on the parsing rules, it
      returns an element with the specified name, otherwise it returns an
      empty sequence. No additional validation (as specified through the
      <my:node>validate</my:node> element) is carried out on the value.
    </dd>
    <dt><code>ns:type-regex() returns xs:string</code></dt>
    <dd>
      This returns a regular expression for the particular datatype.
    </dd>
    <dt><code>ns:matches-type-regex($string as xs:string) returns xs:boolean</code></dt>
    <dd>
      This returns true if the argument string matches the regular expression
      for the datatype (i.e. if <code>ns:parse-name()</code> will succeed).
    </dd>
    <dt><code>ns:validated-type($type as element()) returns element()</code></dt>
    <dd>
      This returns the argument if it's a legal value of the datatype, or raises
      an error if it isn't.
    </dd>
    <dt><code>ns:validate-type($type as element()) returns xs:string*</code></dt>
    <dd>
      This returns a sequence of error messages that result from validating the
      value passed as the argument. If the value is valid, the sequence will be
      empty.
    </dd>
  </dl>
  <p>
    Once you generated the stylesheet using datatypes.xsl, you can import it
    into your own stylesheet to try things out. To start you off, check out:
  </p>
  <ul>
    <li><my:link href="test.dtl">test.dtl</my:link> - a test datatype library</li>
    <li><my:link href="test-datatypes.xsl">test-datatypes.xsl</my:link> - the XSLT 2.0 stylesheet that's generated</li>
    <li><my:link href="test.xsl">test.xsl</my:link> - an XSLT 2.0 stylesheet that uses test-datatypes.xsl</li>
  </ul>
  <h3>Bugs</h3>
  <p>
    This implementation is not bug-free; it's definitely a proof-of-concept
    rather than a finished product. A few things to watch out for:
  </p>
  <ul>
    <li>
      Saxon 7.6.5 uses a Java regex library rather than one based on the XML
      Schema/XPath 2.0 regular expressions, so it doesn't accept all the parse
      specifications that you might want to use. Most of the common ones
      are OK, though.
    </li>
    <li>
      The functions don't currently check whether the elements that they're passed are
      of the kind that they expect, so for example you can pass a <code>my:decimal</code>
      value to the <code>my:validate-date()</code> function and it won't catch
      the error.
    </li>
    <li>
      There is pretty much no error checking to make sure that what you have in
      the datatype library makes sense, so usually you won't know something is
      wrong until you try to use the datatype, and then you might get a very
      obscure error message.
    </li>
  </ul>

  <h2 id="todo">To Do</h2>
  <p>
    There are lots of things left to do, including but not limited to:
  </p>
  <ul>
    <li>add facility for importing/including other datatype libraries</li>
    <li>add facility for declaring/using context information</li>
    <li>look into supporting other languages for the coding parts of the datatype definitions (i.e. casting, normalising)</li>
    <li>look into supporting multiple inheritance</li>
    <li>make sure that this can really represent all the XML Schema datatypes</li>
  </ul>
  
  <h2 id="links">Files</h2>
  <my:links>
    <my:link href="datatypes.rnc">RELAX NG Compact schema</my:link>
    <my:link href="datatypes.rng">RELAX NG schema</my:link>
    <my:link href="datatypes.xsd">XML Schema schema</my:link>
    <my:link href="datatypes.xsl">Meta-Stylesheet</my:link>
    <my:link href="test.dtl">Test datatype library</my:link>
    <my:link href="test-datatypes.xsl">Stylesheet generated from datatype library</my:link>
    <my:link href="test.xsl">Stylesheet for testing</my:link>
  </my:links>

  <h2 id="links">Links</h2>
  <my:links>
    <my:link href="www.relaxng.org">RELAX NG</my:link>
    <my:link href="www.w3.org/TR/xpath20">XPath 2.0</my:link>
    <my:link href="www.dsdl.org">DSDL</my:link>
    <my:link href="www.w3.org/TR/xmlschema-2">XML Schema (Part 2)</my:link>
    <my:link href="http://www.simonstl.com/projects/fragment/">Regular Fragmentations</my:link>
    <my:link href="http://www.ascc.net/xml/schematron/">Schematron</my:link>
    <my:link href="http://saxon.sourceforge.net">Saxon 7</my:link>
    <my:link href="http://www.thaiopensource.com/relaxng/trang.html">Trang</my:link>
  </my:links>
</my:doc>